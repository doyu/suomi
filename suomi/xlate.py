"""Translate Finnish words/phrases to English and Japanese using OpenAI API"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00a_xlate.ipynb.

# %% auto #0
__all__ = ['cli', 'xtexts']

# %% ../nbs/00a_xlate.ipynb #fa87215c
import json
import time
from openai import OpenAI

# %% ../nbs/00a_xlate.ipynb #6fa81b06
def __cli(
    cli: OpenAI,  # OpenAI client instance
    msgs: list[dict],  # List of message dicts
    model: str = "gpt-4o-mini",  # Model name
    temperature: float = 0.3  # Temperature parameter
) -> str:
    """Internal function to call OpenAI API without retry logic."""
    res = cli.chat.completions.create(
        model = model, 
        messages = msgs, 
        response_format = {"type": "json_object"}, 
        temperature = temperature,
    )
    return res.choices[0].message.content

# %% ../nbs/00a_xlate.ipynb #ec068562
def cli(
    cli: OpenAI,
    msgs: list[dict],
    model: str = "gpt-4o-mini",
    max_retries: int = 3
) -> str:
    """Call OpenAI API with exponential backoff retry."""
    for attempt in range(max_retries):
        try:
            return __cli(cli, msgs=msgs, model=model)            
        except Exception as e:
            if attempt == max_retries - 1:
                raise RuntimeError(
                    f"Translation failed after {max_retries} attempts: {e}"
                )
            wait_time = 2 ** attempt
            print(f"Attempt {attempt + 1} failed: {e}. Retrying in {wait_time}s...")
            time.sleep(wait_time)

# %% ../nbs/00a_xlate.ipynb #6949b994
def build_prompts(texts: list[str]) -> tuple[str, str]:
    """Build system and user prompts for translation."""
    finnish_list = "\n".join(f"{i+1}. {text}" for i, text in enumerate(texts))
    
    system_prompt = """You are a professional translator specializing in Finnish to English and Japanese translations.
Your translations should be:
- Natural and contextually appropriate (not overly literal)
- Suitable for language learning (clear and commonly used expressions)
- Consistent in formality level
- Accurate to the source meaning

When translating single words, provide the most common meaning.
When translating phrases or sentences, provide natural conversational translations.
For Japanese, use appropriate formality and include kanji with hiragana where appropriate."""

    user_prompt = f"""Translate the following Finnish texts to English and Japanese.
Return your response as a JSON object with a "translations" key containing an array where each object has: {{"Finnish": "...", "English": "...", "Japanese": "..."}}

Finnish texts to translate:
{finnish_list}"""

    return system_prompt, user_prompt

# %% ../nbs/00a_xlate.ipynb #158a022c
def parse_response(content: str, expected_count: int) -> list[dict]:
    """Parse OpenAI API JSON response."""
    result = json.loads(content)
    
    # Handle different JSON structures
    if isinstance(result, dict) and "translations" in result:
        translations = result["translations"]
    elif isinstance(result, list):
        translations = result
    else:
        # Fallback: try to extract list from dict
        translations = list(result.values())[0] if result else []
    
    # Validate count
    if len(translations) != expected_count:
        raise ValueError(
            f"Expected {expected_count} translations, got {len(translations)}"
        )
    
    return translations

# %% ../nbs/00a_xlate.ipynb #22f58198
def xtexts(
    texts: list[str],          # List of Finnish words/phrases
    client: OpenAI | None = None  # OpenAI client (creates new if None)
) -> list[dict]:             # List of dicts with keys: Finnish, English, Japanese
    """Translate batch of Finnish texts to English and Japanese.
    
    Args:
        texts: List of Finnish words/phrases to translate
        client: OpenAI client instance (optional, creates new if not provided)
    
    Returns:
        List of dicts with keys: Finnish, English, Japanese
    """  
    # Filter out empty/whitespace-only texts
    texts = [t.strip() for t in texts if t.strip()]
    
    # Early return for empty list
    if not texts:
        return []
    
    # Use provided client or create new one
    if client is None:
        client = OpenAI()
    
    prms = build_prompts(texts)
    msgs = [
        {"role": "system", "content": prms[0]},
        {"role": "user", "content": prms[1]}
    ]
    res = cli(client, msgs)
    return parse_response(res, len(texts))
